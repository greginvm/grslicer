from grslicer import VERSION
from grslicer.util.np import to_ndarray, euclidean_dist
from grslicer.path_optimization import follow, follow_objs
from grslicer.util.progress import progress_log


DEFAULT_X_PRECISION = ' X{:.3f}'
DEFAULT_Y_PRECISION = ' Y{:.3f}'
DEFAULT_Z_PRECISION = ' Z{:.3f}'
DEFAULT_E_PRECISION = ' E{:.5f}'
DEFAULT_F_PRECISION = ' F{:.0f}'

SPEED_MAPPING = {
    'supports': 'speedSupports',
    'offsets': 'speedOffsets',
    'contours': 'speedContours',
    'lines': 'speedLines',
    'travel': 'speedTravel',
}

BUFFER_LINES = 100


def encode(model, settings, gcode_file):
    gcoder = GCoder(model, settings, gcode_file)
    gcoder.encode()
    return gcode_file


class GCoder(object):
    def __init__(self, model, settings, gcode_file):
        self.model = model
        self.s = settings
        self.coder = None
        self.gcode_file = gcode_file

        self.home = to_ndarray([0, 0])
        self.start = self.home

        self.change_layer = True
        self.height = 0

        self.e_per_mm = None
        self.e_pos = 0
        self.e_len = 0

    def add_e(self, val):
        self.e_pos += val
        self.e_len += val

    def reset_e(self):
        self.e_pos = 0
        self.coder.reset_position(e=self.e_pos)

    @progress_log('Write layers to G-Code')
    def encode(self, progress):

        with open(self.gcode_file, mode='w', buffering=1024 ** 2) as fs:

            self.coder = RepRapGCoder(fs, self.s.verbose)
            self.encode_start_block()

            progress.set_size(len(self.model.layers) + 2)

            for seq_nr, layer in self.model.layers.items():
                self.encode_layer(layer, seq_nr)

                progress.inc()

            self.encode_end_block()
            progress.inc()

            self.coder.finalize()

        progress.done()

    def encode_start_block(self):
        self.coder.comment('Generated by GRSlicer {}'.format((VERSION,)))
        self.coder.set_units()
        self.coder.set_nozzle_temp(self.s.nozzleTemperature)
        self.coder.set_bed_temp(self.s.bedTemperature)
        self.coder.home()
        self.coder.move(z=5)
        self.coder.wait_nozzle_temp(self.s.nozzleTemperature)
        self.coder.wait_bed_temp(self.s.bedTemperature)

    def encode_end_block(self):
        self.retract()
        self.coder.move(z=self.height + 5, f=self.feedrate('travel'))
        self.coder.set_nozzle_temp(0)
        self.coder.set_bed_temp(0)
        self.coder.disable_motors()

    def encode_layer(self, layer, layer_seq_nr):

        self.set_e_per_mm(self.height, layer.height)
        self.change_layer = True
        self.height = layer.height
        self.reset_e()

        self.coder.comment('Layer {} at height {}'.format(layer.seq_nr, layer.height))

        if layer.skirts:
            self.coder.comment('Layer {} SKIRTS'.format(layer.seq_nr))
            self.encode_paths(layer.skirts, closed=True, f=self.feedrate('supports', layer_seq_nr))

        perimeters, islands = [], []
        for island in layer.islands:
            perimeters.extend(island.perimeters)
            islands.extend([island] * len(island.perimeters))

        for island in follow_objs(perimeters, lambda: self.start, islands, closed=True):
            self.coder.comment('Layer {} island {}'.format(layer.seq_nr, str(island)))
            offsets = island.offsets[::-1]

            # print offsets
            for i, offset in enumerate(offsets):
                self.coder.comment('Layer {} island {} OFFSETS'.format(layer.seq_nr, str(island)))
                self.encode_paths(offset, closed=True,
                                  f=self.feedrate('offsets' if i + 1 < len(offsets) else 'contours', layer_seq_nr))

            # print lines
            self.coder.comment('Layer {} island {} LINES'.format(layer.seq_nr, str(island)))
            self.encode_paths(island.inner_infill, closed=False, f=self.feedrate('lines', layer_seq_nr))

    def encode_paths(self, paths, closed, f):
        i = 0
        for path, end in follow(paths, lambda: self.start, closed):

            self.travel_to(path[0], path_seq_nr=i)

            for j, v in enumerate(path):

                # skip first vertex, because we already traveled there
                if j is not 0:
                    self.move(vertex=v, ce=True, f=f)

            if closed:
                self.move(vertex=path[0], ce=True, f=f)

            self.start = end
            i += 1

    def move_by_path(self, path, seq_nr, f):

        self.travel_to(path[0], seq_nr)

        for i, v in enumerate(path):
            if i is not 0:
                self.move(vertex=v, ce=True, f=f)

        self.start = path[-1]

    def retract(self):
        if abs(self.s.retractLength) > 0:
            self.coder.comment('Retract')
            self.move(e=-abs(self.s.retractLength), f=self.feedrate('travel'))

    def spit(self):
        if abs(self.s.spitLength) > 0:
            self.coder.comment('Spit')
            self.move(e=abs(self.s.spitLength), f=self.feedrate('travel'))

    def should_retract(self, path_seq_nr, is_layer_change):
        if is_layer_change and self.s.retractEachLayer:
            return True

        return self.s.retractFirstPath if path_seq_nr is 0 else self.s.retractEachPath

    def feedrate(self, part, layer_seq_nr=None):
        selector = SPEED_MAPPING[part]
        speed = self.s[selector]
        if layer_seq_nr is not None and self.s.speedModifierLayers and layer_seq_nr < self.s.speedModifierLayers:
            speed = speed * self.s.speedModifier
        return speed

    def set_e_per_mm(self, prev_height, current_height):
        self.e_per_mm = _e_per_mm(self.s.extrusionWidth, current_height - prev_height,
                                  self.s.filamentDiameter, self.s.extrusionMultiplier)
        self.coder.comment('E per mm {}'.format(self.e_per_mm))

    def travel_to(self, start, path_seq_nr):

        z = None
        if self.change_layer:
            z = self.height

        should_retract = self.should_retract(path_seq_nr, self.change_layer)
        self.change_layer = False

        if should_retract:
            self.retract()

        self.coder.comment('Travel z={}'.format(z))
        self.move(vertex=start, z=z, e=None, f=self.feedrate('travel'))

        if should_retract:
            self.spit()

    def move(self, vertex=None, x=None, y=None, z=None, e=None, ce=False, f=None):
        if vertex is not None:
            x = vertex[0]
            y = vertex[1]

        if ce:
            # calculate e
            e = euclidean_dist(self.start, vertex if vertex is not None else to_ndarray([x, y])) * self.e_per_mm

        if e:
            self.add_e(e)
            e = self.e_pos

        self.coder.move(x, y, z, e, f)


class RepRapGCoder(object):
    def __init__(self, fs, verbose=True):
        self.fs = fs
        self.verbose = verbose
        self.buffer_count = 0
        self.buffer = ""

    def set_units(self):
        self.comment('Set units to millimeters')
        self.write_line('G21')

    def set_abs_positioning(self):
        self.comment('Set absolute positioning')
        self.write_line('M90')

    def set_nozzle_temp(self, temp):
        self.comment('Set extruder temperature')
        self.write_line('M104 S{}'.format(temp))

    def set_bed_temp(self, temp):
        self.comment('Set bed temperature')
        self.write_line('M140 S{}'.format(temp))

    def disable_motors(self):
        self.comment('Disable motors')
        self.write_line('M84')

    def reset_position(self, x=None, y=None, z=None, e=None):
        self.command_position('G92', x, y, z, e)

    def wait_nozzle_temp(self, temp):
        self.comment('Wait for nozzle temperature to be reached')
        self.write_line('M109 S{}'.format(temp))

    def wait_bed_temp(self, temp):
        self.comment('Wait for bed temperature to be reached')
        self.write_line('M190 S{}'.format(temp))

    def home(self, x=None, y=None, z=None):
        self.comment('Home')
        axes = []
        if x is not None:
            axes.append('X')
        if y is not None:
            axes.append('Y')
        if z is not None:
            axes.append('Z')
        self.write_line('G28 ' + ' '.join(axes))

    def move(self, x=None, y=None, z=None, e=None, f=None):
        self.command_position('G1', x, y, z, e, f)

    def command_position(self, command, x=None, y=None, z=None, e=None, f=None):
        self.write(command)
        if x is not None:
            self.write(DEFAULT_X_PRECISION.format(x))
        if y is not None:
            self.write(DEFAULT_Y_PRECISION.format(y))
        if z is not None:
            self.write(DEFAULT_Z_PRECISION.format(z))
        if e is not None:
            self.write(DEFAULT_E_PRECISION.format(e))
        if f is not None:
            self.write(DEFAULT_F_PRECISION.format(f))
        self.nl()

    # def parameter(self, axis, value, precision):
    # self.write('{0}{2:.{1}f}'.format(axis, precision, value))

    def comment(self, text):
        if self.verbose:
            self.write(';')
            self.space()
            self.write(text)
            self.nl()

    def write_line(self, text):
        self.write(text)
        self.nl()

    def space(self):
        self.write(' ')

    def nl(self):
        self.write('\n')

    def write(self, text):
        self.buffer += text
        self.buffer_count += 1
        if self.buffer_count >= BUFFER_LINES:
            self.fs.write(self.buffer)
            self.buffer_count = 0
            self.buffer = ""

    def finalize(self):
        if self.buffer:
            self.fs.write(self.buffer)


def _e_per_mm(ew, eh, fd, multiplier=1.0):
    """ How much filament has to be feed in mm so that we get 1mm of extrusion.
    Extrusion cross section is assumed to be ellipse with major axis extrusion width
    and minor axis layer height.

    Filament cross section is assumed to be circular where filament diameter is the
    diameter of that circle.
    """

    return ew * eh * multiplier / (fd ** 2)